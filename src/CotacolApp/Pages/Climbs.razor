@page "/climbs"
@using MatBlazor
@inject ICotacolClient CotacolClient
@inject ICotacolUserClient CotacolUserClient
@inject IUserProfileManager UserProfile

<h1>Climbs</h1>

<p>1000 Cotacol climbs for you to conquer.</p>
@if (climbs == null)
{
    <p>
        <em>Loading climbs...</em>
    </p>
}
else
{
    <MatDrawerContainer>
        <MatDrawer Mode="MatDrawerMode.Dismissible" @bind-Opened="@ColSelected" Style="width: 270px">
            <MatIconButton OnClick="CloseClimb">
                <MatIcon>@MatIconNames.Close</MatIcon>
            </MatIconButton>
            <ClimbDetailComponent Cotacol="@SelectedClimb"/>
        </MatDrawer>
        <MatDrawerContent>
            <MatChipSet Choice="true" SelectedChipChanged="ApplyFilter">
                <MatChip Label="All" Id="NoFilter"></MatChip>
                @if (UserProfile.IsAuthenticated)
                {
                    <MatChip Label="Done" Id="DoneFilter"></MatChip>
                    <!--<MatChip Label="Planned" Id="PlannedFilter"></MatChip>-->
                    <MatChip Label="To do" Id="TodoFilter"></MatChip>
                }
                <MatChip Label="Top 50" Id="TopFilter"></MatChip>
                <MatChip Label="Easiest" Id="EasyFilter"></MatChip>
                <MatChip Label="Highest" Id="HighFilter"></MatChip>
                <MatChip Label="Longest" Id="LongFilter"></MatChip>
                <MatChip Label="Steepest" Id="SteepFilter"></MatChip>
            </MatChipSet>
            <div style="overflow-y: scroll; height:100vh;">
                <MatTable FilterByColumnName="Name" Items="@climbs" class="table" PageSize="2000"
                      AllowSelection="true" SelectionChanged="SelectionChanged"
                      ShowPaging="false" UseSortHeaderRow="true">
                <MatTableHeader>
                    <MatSortHeaderRow SortChanged="SortClimbs">
                        <MatSortHeader SortId="id">#</MatSortHeader>
                        <MatSortHeader SortId="name">
                            <span style="width:250px">Name</span>
                        </MatSortHeader>
                        <MatSortHeader SortId="province">Province</MatSortHeader>
                        <MatSortHeader SortId="surface">Surface</MatSortHeader>
                        <MatSortHeader SortId="points">Points</MatSortHeader>
                        <MatSortHeader SortId="length">Length</MatSortHeader>
                        <MatSortHeader SortId="elevation">Elevation</MatSortHeader>
                        <MatSortHeader SortId="grade">Grade</MatSortHeader>
                        <MatSortHeader>Link</MatSortHeader>
                    </MatSortHeaderRow>
                </MatTableHeader>
                <MatTableRow>
                    <td>@context.Id</td>
                    @if (context.Done)
                    {
                        <td style="max-width: 200px">
                            <b>@context.Name.ToUpper()</b>
                        </td>
                    }
                    else
                    {
                        <td style="max-width: 200px">@context.Name</td>
                    }
                    <td>@context.Province</td>
                    <td>@context.Surface</td>
                    <td>@context.CotacolPoints</td>
                    <td>@context.Distance</td>
                    <td>@context.ElevationDiff</td>
                    <td>@context.AvgGrade %</td>
                    <td>
                        <a href="@context.Url" target="_blank">
                            <img src="images/strava-logo-small.png" asp-append-version="true"/>
                        </a>
                    </td>
                </MatTableRow>
            </MatTable>
            </div>
        </MatDrawerContent>
    </MatDrawerContainer>
}

@code {
    private bool ColSelected = false;
    private UserClimb SelectedClimb = null;
    private IEnumerable<UserClimb> climbList;
    private IEnumerable<UserClimb> climbs;

    protected override async Task OnInitializedAsync()
    {
        if (UserProfile.IsAuthenticated)
        {
            climbList = await CotacolUserClient.GetClimbDataAsync();
        }
        else
        {
            climbList = (await CotacolClient.GetClimbDataAsync()).Select(climb => new UserClimb(climb));
        }
        climbs = climbList;
    }

    private void ApplyFilter(MatChip filter)
    {
        climbs = climbList;

        switch (filter.Id?.ToLower())
        {
            case "nofilter":
                break;
            case "donefilter":
                climbs = climbList.Where(c => c.Done);
                break;
            case "todofilter":
                climbs = climbList.Where(c => !c.Done);
                break;
            case "topfilter":
                climbs = climbList.OrderByDescending(c => c.CotacolPoints).Take(50);
                break;
            case "easyfilter":
                climbs = climbList.OrderBy(c => c.CotacolPoints).Take(50);
                break;
            case "highfilter":
                climbs = climbList.OrderByDescending(c => c.ElevationDiff).Take(50);
                break;
            case "longfilter":
                climbs = climbList.OrderByDescending(c => c.Distance).Take(50);
                break;
            case "steepfilter":
                climbs = climbList.OrderByDescending(c => c.AvgGrade).Take(50);
                break;
            default:
                break;
        }
    }

    private void SortClimbs(MatSortChangedEvent sort)
    {
        if (!(sort == null || sort.Direction == MatSortDirection.None || string.IsNullOrEmpty(sort.SortId)) && climbs != null)
        {
            switch (sort.SortId)
            {
                case "id":
                    climbs = sort.Direction == MatSortDirection.Asc ?
                        climbs.OrderBy(c => c.Id) :
                        climbs.OrderByDescending(c => c.Id);
                    break;
                case "name":
                    climbs = sort.Direction == MatSortDirection.Asc ?
                        climbs.OrderBy(c => c.Name) :
                        climbs.OrderByDescending(c => c.Name);
                    break;
                case "province":
                    climbs = sort.Direction == MatSortDirection.Asc ?
                        climbs.OrderBy(c => c.Province) :
                        climbs.OrderByDescending(c => c.Province);
                    break;
                case "surface":
                    climbs = sort.Direction == MatSortDirection.Asc ?
                        climbs.OrderBy(c => c.Surface) :
                        climbs.OrderByDescending(c => c.Surface);
                    break;
                case "points":
                    climbs = sort.Direction == MatSortDirection.Asc ?
                        climbs.OrderBy(c => c.CotacolPoints) :
                        climbs.OrderByDescending(c => c.CotacolPoints);
                    break;
                case "length":
                    climbs = sort.Direction == MatSortDirection.Asc ?
                        climbs.OrderBy(c => c.Distance) :
                        climbs.OrderByDescending(c => c.Distance);
                    break;
                case "elevation":
                    climbs = sort.Direction == MatSortDirection.Asc ?
                        climbs.OrderBy(c => c.ElevationDiff) :
                        climbs.OrderByDescending(c => c.ElevationDiff);
                    break;
                case "grade":
                    climbs = sort.Direction == MatSortDirection.Asc ?
                        climbs.OrderBy(c => c.AvgGrade) :
                        climbs.OrderByDescending(c => c.AvgGrade);
                    break;
            }
        }
    }

    private void SelectionChanged(object col)
    {
        if (col is UserClimb climb)
        {
            SelectedClimb = climb;
            Console.WriteLine(climb.Name);
            StateHasChanged();
        }
        ColSelected = col != null;
    }

    private void CloseClimb()
    {
        SelectedClimb = null;
        StateHasChanged();
    }

}